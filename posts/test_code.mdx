---
title: コードテスト用
date: '1970/01/01'
description: コードテスト
thumbnailUrl: '/mathematician.png'
tags: []
---

# コードテスト用

```cpp:a.cpp
//#define _GLIBCXX_DEBUG
#include <bits/stdc++.h>
using namespace std;
#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
#endif
#define rrep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep(i, n) rrep(i,0,n)
#define bfor(bit,a,b) for(int bit = (a); bit < (1<<(b)); ++bit)
#define brep(bit,n) bfor(bit,0,n)
typedef pair<int, int> PII;
typedef long long ll;
typedef long double ld;
const int INF = INT_MAX / 2; const ll INFL = 1LL << 60;
#define MOD (ll)998244353
#define ALL(a)  (a).begin(),(a).end()

// 辺の情報
struct Edge
{
	// 行先
	ll to;

	// コスト
	ll cost;
};

using Graph = std::vector<std::vector<Edge>>;

// { distance, from }
using Pair = std::pair<long long, long long>;

// ダイクストラ法 (1.1 基本実装)
// distances は頂点数と同じサイズ, 全要素 INF で初期化しておく
void Dijkstra(const Graph& graph, std::vector<long long>& distances, int startIndex)
{
	// 「現時点での最短距離, 頂点」の順に取り出す priority_queue
	// デフォルトの priority_queue は降順に取り出すため std::greater を使う
	std::priority_queue<Pair, std::vector<Pair>, std::greater<Pair>> q;
	q.emplace((distances[startIndex] = 0), startIndex);

	while (!q.empty())
	{
		const long long distance = q.top().first;
		const int from = q.top().second;
		q.pop();

		// 最短距離でなければ処理しない
		if (distances[from] < distance)
		{
			continue;
		}

		// 現在の頂点からの各辺について
		for (const auto& edge : graph[from])
		{
			// to までの新しい距離
			const long long d = (distances[from] + edge.cost);

			// d が現在の記録より小さければ更新
			if (d < distances[edge.to])
			{
				q.emplace((distances[edge.to] = d), edge.to);
			}
		}
	}
    
}



int main() {
    // 入力を受け取る
    int N, M, r; cin >> N >> M >> r;

    vector<vector<Edge>> G(N);  // G[i]：頂点 i を始点とする辺情報を格納する
    for(int i = 0; i < M; ++i) {
        int u, v, w; cin >> u >> v >> w;
        //u--;v--;
        G[u].push_back({v, w});
        //G[v].push_back({u, w});
    }

    vector<ll> dist(N, INFL);   // dist[i]：頂点 0 から頂点 i への暫定的な経路長

    Dijkstra(G, dist, r);

    rep(i,N)cout << dist[i] << endl;

}
```

